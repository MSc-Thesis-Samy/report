\chapter{The framework}
\label{chap:framework}

This chapter presents the design and implementation of the framewor which was developed as part of this thesis.
It list the requirements of the framework, goes through its development lifecycle and presents the architecture of the framework.

This framework, which is the main contribution of this thesis, allows for a fair comparison of the considered algorithms by having them implemented in a common environment
and language, in order to avoid performacne differences induced by the programming language, and running them on the exact same benchmark problem implementations and
settings.

The code for the framework is available at \url{https://github.com/MSc-Thesis-Samy/code} and includes a README file with instructions on how to use it.

\section{Requirements}

\subsection{Goals and functional requirements}

The overreaching goal of the framework is to provide a tool for the evaluation of neuroevolution algorithms on benchmark problems, based on the selection
presented in \Cref{chap:review}.
Tests are specified through a command line interface, they consist in an algorithm and problem pair, along with a set of additional parameters.
The framework collects the results of the tests as well as the list of passed-in parameters, algorithm and problem.
These tests can either be run individually or in batch mode, where the framework runs a set of tests in parallel, and collects statistics on these runs.

Furthermore, the framework also allows for the visualization of the problem, solution process and network structure through a graphical user interface.
In addition, it generates graphs for visualizing the test results, plotting the performance of the algorithm on the benchmark problem over the generation count.

\subsection{Non-functional requirements}

Non-functional requirements are the requirements that specify the quality of the system, rather than the features it should have.
Apart from the functional requirements that specify the features expected of the framework, a number of non-functional requirements have also been identified.

\begin{itemize}
    \item Usability and user experience: the framework should be easy to use and provide a good user experience.
    \item Documentation: The framework should be well documented, providing a clear and concise guide on how to use it.
    \item Error handling: All errors should be handled gracefully as to not result in runtime errors.
    \item Performance: The framework should allow for the execution of tests in parallel, making use of multiple CPU cores.
    \item:Extensibility: The framework should be easily extensible, allowing for the addition of algorithms and benchmarks without any
    major changes to the existing codebase.
    \item Support: The framework should be able to run on the three major operating systems: Windows, Linux and MacOS.
\end{itemize}

\section{Architecture}

The framework is implemented in Rust. This general-purpose programming language, originally intended to serve as an alternative for system languages such as C and
C++, offers a good balance between performance provided by such low-level languages and the safety and ease of use of higher-level languages such as Python.
Furthermore, various libraries (referred to as Rust crates) which could be used when implementing aspects of the framework, such as designing the command-line interfaces
and graphical-user interfaces, or running CMA\_ES are available in Rust.
Lastly, the language can target a range of platforms, including Windows, Linux and MacOS.

The framework is divided into three main components:

\begin{itemize}
    \item The core: This component is responsible for the execution of the tests and the collection of results. It contains the algorithms and benchmark implementations.
    \item The command-line interface: This component allows the user to specify the tests to be run, as well as the parameters for these tests.
    \item The graphical user interface: This component allows the user to visualize the problem, solution process and network structure, as well as the test results.
\end{itemize}

The dependency graph of the framework is shown in \Cref{fig:dependency_graph}.

% TODO add dependency graph

\subsection{Background on Rust features}

This section provides a brief overview of the features of the Rust programming language before going into the details of the framework's implementation.

\subsubsection{Object-oriented capabilities}

Nowadays, object-oriented languages are considered the norm for the development of large-scale software systems in the industry.
Rust is inspired by various programming paradigms, such as functional programming and object-oriented programming.
Although there is no consensus on the list of features which define an object-oriented programming language, Rust can be considered object-oriented.
Indeed, it allows for the definition of structs and enums which can store data and methods using implementation blocks.
It also allows for encapsulation through the use of the \texttt{pub} keyword, which specifies the visibility of objects, thus defining the public API for interacting
with them. When not using the \texttt{pub} keyword, the object is private and can only be accessed by the module it is defined in.
Modules are used to organize code and define the visibility of objects, and can be nested to form a hierarchy.
However, a major difference with other object-oriented languages such as Java or C\# is that Rust does not have a class-based inheritance system.
Instead, it takes a different approach which consists in polymorphism, which is a more general system referring to code that can work with multiple types.
In practice, this is achieved through the use of generics in method and object definitions, and the use of traits, which are similar to interfaces in other languages.
In fact, traits allow for the definition of a default implementation for a set of methods, which can be overridden by the implementing type.

\subsubsection{Library management}

Cargo is Rust's build system and package manager. Most projects are managed using this tool which handles the download and building of the dependencies of projects.
In Rust, packages are referred to as crates.

\subsection{Core}

...

\subsection{Command-line interface}

...

\subsection{Graphical user interface}

...
