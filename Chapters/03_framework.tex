\chapter{The framework}
\label{chap:framework}

This chapter presents the design and implementation of the framewor which was developed as part of this thesis.
It list the requirements of the framework, goes through its development lifecycle and presents the architecture of the framework.

This framework, which is the main contribution of this thesis, allows for a fair comparison of the considered algorithms by having them implemented in a common environment
and language, in order to avoid performacne differences induced by the programming language, and running them on the exact same benchmark problem implementations and
settings.

The code for the framework is available at \url{https://github.com/MSc-Thesis-Samy/code} and includes a README file with instructions on how to use it.

\section{Requirements}

\subsection{Goals and functional requirements}

The overreaching goal of the framework is to provide a tool for the evaluation of neuroevolution algorithms on benchmark problems, based on the selection
presented in \Cref{chap:review}.
Tests are specified through a command line interface, they consist in an algorithm and problem pair, along with a set of additional parameters.
The framework collects the results of the tests as well as the list of passed-in parameters, algorithm and problem.
These tests can either be run individually or in batch mode, where the framework runs a set of tests in parallel, and collects statistics on these runs.

Furthermore, the framework also allows for the visualization of the problem, solution process and network structure through a graphical user interface.
In addition, it generates graphs for visualizing the test results, plotting the performance of the algorithm on the benchmark problem over the generation count.

\subsection{Non-functional requirements}

Non-functional requirements are the requirements that specify the quality of the system, rather than the features it should have.
Apart from the functional requirements that specify the features expected of the framework, a number of non-functional requirements have also been identified.

\begin{itemize}
    \item Usability and user experience: the framework should be easy to use and provide a good user experience.
    \item Documentation: The framework should be well documented, providing a clear and concise guide on how to use it.
    \item Error handling: All errors should be handled gracefully as to not result in runtime errors.
    \item Performance: The framework should allow for the execution of tests in parallel, making use of multiple CPU cores.
    \item:Extensibility: The framework should be easily extensible, allowing for the addition of algorithms and benchmarks without any
    major changes to the existing codebase.
    \item Support: The framework should be able to run on the three major operating systems: Windows, Linux and MacOS.
\end{itemize}

\section{Architecture}

The framework is implemented in Rust. This general-purpose programming language, originally intended to serve as an alternative for system languages such as C and
C++, offers a good balance between performance provided by such low-level languages and the safety and ease of use of higher-level languages such as Python.
Furthermore, various libraries (referred to as Rust crates) which could be used when implementing aspects of the framework, such as designing the command-line interfaces
and graphical-user interfaces, or running CMA\_ES are available in Rust.
Lastly, the language can target a range of platforms, including Windows, Linux and MacOS.

The framework is divided into three main components:

\begin{itemize}
    \item The core: This component is responsible for the execution of the tests and the collection of results. It contains the algorithms and benchmark implementations.
    \item The command-line interface: This component allows the user to specify the tests to be run, as well as the parameters for these tests.
    \item The graphical user interface: This component allows the user to visualize the problem, solution process and network structure, as well as the test results.
\end{itemize}

% TODO check this
The core is used by both the command line interface and the graphical user interface. And the graphical user interface is used by the command line interface.
Indeed, the UI allows for the visualization of the solution process, but interaction with the framework is done when invoking it through the command line interface.

The dependency graph of the framework is shown in \Cref{fig:dependency_graph}.

% TODO add dependency graph

\subsection{Background on Rust features}

This section provides a brief overview of the features of the Rust programming language before going into the details of the framework's implementation.

\subsubsection{Object-oriented capabilities}

Nowadays, object-oriented languages are considered the norm for the development of large-scale software systems in the industry.
Rust is inspired by various programming paradigms, such as functional programming and object-oriented programming.
Although there is no consensus on the list of features which define an object-oriented programming language, Rust can be considered object-oriented.
Indeed, it allows for the definition of structs and enums which can store data and methods using implementation blocks.
It also allows for encapsulation through the use of the \texttt{pub} keyword, which specifies the visibility of objects, thus defining the public API for interacting
with them. When not using the \texttt{pub} keyword, the object is private and can only be accessed by the module it is defined in.
Modules are used to organize code and define the visibility of objects, and can be nested to form a hierarchy.
However, a major difference with other object-oriented languages such as Java or C\# is that Rust does not have a class-based inheritance system.
Instead, it takes a different approach which consists in polymorphism, which is a more general system referring to code that can work with multiple types.
In practice, this is achieved through the use of generics in method and object definitions, and the use of traits, which are similar to interfaces in other languages.
In fact, traits allow for the definition of a default implementation for a set of methods, which can be overridden by the implementing type.

\subsubsection{Library management}

Cargo is Rust's build system and package manager. Most projects are managed using this tool which handles the download and building of the dependencies of projects.
In Rust, packages are referred to as crates.

\subsubsection{Attributes}

Attributes are metadata applied to some module, crate or object. They are, for example, used to enable compiler features or mark functions as unit tests.
or to define the behavior of the code. They are defined using the \texttt{\#} symbol and are placed before the object they are associated with.

\subsection{Core}

...

\subsection{Command-line interface}

The command lien interface is implemented using the \texttt{clap} crate, which is a widely used command line argument parser in Rust.
It allows for the execution of tests, by providing the algorithm, the problem and additional parameters. These additional parameters are optional and have
default values, they are used to specify parameters for the algorithms, such as the number of neurons, parameters for the optimization, such as the number of
iterations, and toggling the visualization of the solution process and network structure.

Arguments can be of three different types:

\begin{itemize}
    \item \textbf{Positional}: These are required arguments which are specified in the order they are defined in the command line interface.
    \item \textbf{Named}: These are optional arguments which are specified by their name and a value.
    \item \textbf{Flags}: These are optional arguments which are specified by their name and are either present or not.
\end{itemize}

The \texttt{Cli} struct is defined in the \texttt{cli.rs} file, it contains members for each of the command line arguments and derives the \texttt{Parser} trait.
The argument name is set to the member name, a short name,help message, default value and the argument type are specifies in an attribute on the member.

The arguments are parsed in the \texttt{bin/main.rs} file, which is the entry point of the program.

In order to ensure that the passed-in arguments are valid, the rust type system is leveraged, specifying appropriate data types for each of the argument.
For example, the iteration number is set to an unsigned integer \texttt{u32}, while the algoithm and benchmarks are set to two enums, \texttt{AlgorithmType} and
\texttt{Problem}, with variants for each possible option.

The command line interface is shown in \ref{verb:cli}.

% TODO update
\begin{document}
\begin{lstlisting}[label=verb:cli,caption=Command line interface,float,frame=tb]
Neuroevolution framework for testing algorithms on benchmark problems.

Usage: main [OPTIONS] <ALGORITHM> <PROBLEM>

Arguments:
  <ALGORITHM>  The algorithm to test [possible values: oneplusonena, bna]
  <PROBLEM>    the benchmark problem [possible values: half, quarter, two-quarters]

Options:
  -r, --resolution <RESOLUTION>  Resolution, when applicable [default: 1000]
  -i, --iterations <ITERATIONS>  Number of iterations [default: 5000]
  -c, --continuous               Use the continuous version of the algorithm, when applicable
  -e, --es                       Optimize using cma-es
  -n, --neurons <NEURONS>        Number of neurons, when applicable [default: 1]
  -g, --gui                      Display visualization
  -h, --help                     Print help
  -V, --version                  Print version
\end{lstlisting}


\subsection{Graphical user interface}

The UI is implemented using the \texttt{ggez} crate, which is intended to be a simple 2D game framework.
In particular, it provides a simple interface for creating windows, drawing geometrical shapes and handling user input.
This crate relies on the definition of a \texttt{State} struct, which holds the parameters of the game state, and which implements the \texttt{EventHandler} trait.
This trait defines two methods: \texttt{update}, which is used for updating the state, and \texttt{draw} which is used for rendering the state.
These two methods are called by the game loop, which is triggered in the \texttt{bin/main.rs} file if the \texttt{gui} flag is set.

This game abstraction is particularly suited for the implementation of visualization in the framework.
The \texttt{State} struct defined in \texttt{gui.rs} holds an \texttt{algorithm}, a \texttt{problem}, and two additioal members keeping track of the number of iterations.
An instance of this struct is created in the \texttt{bin/main.rs} file using the arguments passed in the command line interface.
The \texttt{update} method updates the \texttt{algorithm} by running an optimization step, and the \texttt{draw} renders the different visualizations, based on
the \texttt{problem} and \texttt{algorithm} members.

The number of iterations and the best fitness value are shown in the top left corner of the window.

...

\subsubsection{Sphere classification problems}

For the sphere classification problem, the unit-sphere is shown, along with its points which are labeled as \texttt{true}, which are shown in green, and its points
labeled as \texttt{false} which are shown in red. When running the (1 + 1) NA algorithm, the decision line and normal vector are shown. In the case of the BNA algorithm,
the normal vector and decision cones are shown.

% TODO figure

...
